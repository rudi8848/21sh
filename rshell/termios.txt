Обработка и чтение данных
     Терминальное устройство, связанное с файлом терминала, может работать в полнодуплексном режиме, так что данные могут поступать даже при выходе. Каждый файл терминального устройства ассоциировал с ним входную очередь, в которую входящие данные хранятся системой, прежде чем они будут прочитаны процессом. Система налагает предел, {MAX_INPUT}, на количество байтов, которые могут быть сохранены во входной очереди. Поведение системы при превышении этого предела зависит от установки флага IMAXBEL в termios c_iflag. Если этот флаг установлен, терминал отправляется символом BEL ASCII каждый раз, когда символ принимается, когда очередь ввода заполнена. В противном случае очередь ввода будет сброшена после получения символа.



     Доступны два основных вида обработки ввода, определяемые тем, находится ли файл терминала в каноническом режиме или неканоническом режиме. Кроме того, входные символы обрабатываются в соответствии с полями c_iflag и c_lflag. Такая обработка может включать в себя эхо-сигнал, который в общем случае означает передачу входных символов непосредственно обратно на терминал, когда они принимаются от терминала. Это полезно для терминалов, которые могут работать в полнодуплексном режиме.

     Способ, которым данные предоставляются для чтения процесса из файла терминала, зависит от того, находится ли файл терминала в каноническом или неканоническом режиме.

     Другая зависимость заключается в том, установлен ли флаг O_NONBLOCK с помощью функции open () или fcntl (). Если флаг O_NONBLOCK свободен, запрос чтения блокируется до тех пор, пока не будут доступны данные или не будет получен сигнал. Если установлен флаг O_NONBLOCK, запрос на чтение завершается без блокировки одним из трех способов:

           1. Если для удовлетворения всего запроса имеется достаточно данных, и чтение завершается успешно, возвращается количество прочитанных байтов.

           2. Если для удовлетворения всего запроса недостаточно данных, и чтение завершается успешно, считывая как можно больше данных, возвращается количество прочитанных байтов.

           3. Если данных нет, чтение возвращает -1, а errno - в EAGAIN.

     Когда данные доступны, зависит от того, каков ли режим обработки ввода каноническим или неканоническим.


 Обработка входного канонического режима
     При обработке ввода в каноническом режиме вход терминала обрабатывается в единицах строк. Строка разделяется символом «\ n» новой строки, символом конца файла (EOF) или символом конца строки (EOL). Дополнительную информацию об EOF и EOL см. В разделе «Специальные символы». Это означает, что запрос на чтение не будет возвращен до тех пор, пока не будет напечатана целая строка или не будет получен сигнал. Кроме того, независимо от того, сколько байтов запрашивается при вызове чтения, возвращается не более одной строки. Однако не обязательно читать целую строку сразу; любое количество байтов, даже одно, может быть запрошено в чтении без потери информации.

     {MAX_CANON} - это ограничение на количество байтов в строке. Поведение системы при превышении этого предела такое же, как при превышении предела очереди ввода {MAX_INPUT}.

     Обработка удаления и уничтожения происходит, когда принимается один из двух специальных символов, символы ERASE и KILL (см. Раздел «Специальные символы»). Эта обработка влияет на данные во входной очереди, которая еще не была ограничена символом NL, EOF или EOL символа новой строки. Эти данные без разделителей составляют текущую строку. Символ ERASE удаляет последний символ в текущей строке, если таковой имеется. Символ KILL удаляет все данные в текущей строке, если они есть. Символы ERASE и KILL не действуют, если в текущей строке нет данных. Символы ERASE и KILL не помещаются во входную очередь.


Обработка неканонического режима ввода
     При обработке ввода неканонического режима входные байты не собираются в строки, а обработка удаления и уничтожения не происходит. Значения членов MIN и TIME массива c_cc используются для определения способа обработки полученных байтов.

     MIN представляет собой минимальное количество байтов, которое должно быть получено, когда функция чтения успешно возвращается. TIME - таймер с 0,1-секундной гранулярностью, который используется для выключения пакетных и краткосрочных передач данных. Если MIN больше {MAX_INPUT}, ответ на запрос не определен. Ниже приведены четыре возможных значения MIN и TIME и их взаимодействия.

Случай A: MIN> 0, TIME> 0
     В этом случае TIME служит в качестве таймера между байтами и активируется после приема первого байта. Поскольку это промежуточный таймер, он сбрасывается после приема байта. Взаимодействие между MIN и TIME выглядит следующим образом: как только принимается один байт, запускается таймер между байтами. Если MIN байты принимаются до истечения интервала таймера (помните, что таймер сбрасывается после получения каждого байта), чтение выполняется. Если таймер истекает до получения MIN байтов, символы, полученные в эту точку, возвращаются пользователю. Обратите внимание, что если TIME истекает, по крайней мере, один байт возвращается, потому что таймер не был включен, если не был получен байт.
В этом случае (MIN> 0, TIME> 0) блокирует чтение до тех пор, пока механизмы MIN и TIME не активируются при получении первого байта или не будут получены сигналы. Если данные находятся в буфере во время чтения (), результат будет таким, как если бы данные были получены сразу после чтения ().

   Случай B: MIN> 0, TIME = 0
     В этом случае, поскольку значение TIME равно нулю, таймер не играет роли, и только MIN является значительным. Ожидаемое чтение не выполняется до тех пор, пока не будут приняты МИН байт (то есть ожидающие блоки считывания до тех пор, пока не будут приняты МИН байт) или сигнал будет принят. Программа, использующая этот случай для чтения терминалов ввода-вывода на основе записи, может неограниченно блокировать операцию чтения.

   Случай C: MIN = 0, TIME> 0
     В этом случае, поскольку MIN = 0, TIME больше не представляет собой таймер между байтами. Теперь он служит таймером чтения, который активируется, как только обрабатывается функция чтения. Чтение выполняется, как только принимается один байт, или таймер чтения истекает. Обратите внимание, что в этом случае, если таймер истекает, байты не возвращаются. Если таймер не истекает, единственный способ, которым может быть прочитан, - это получение байта. В этом случае чтение не будет блокировать бесконечное ожидание байта; если байт не принимается в течение TIME * 0,1 секунды после начала чтения, считывание возвращает значение нуля, не прочитав никаких данных. Если данные находятся в буфере во время чтения, таймер запускается, как если бы данные были получены сразу после чтения.

   Случай D: MIN = 0, TIME = 0
     Минимальное количество запрошенных байтов или количество доступных в настоящее время байтов, не ожидая ввода большего количества байтов. Если символы не доступны, чтение возвращает значение нуля, не прочитав никаких данных.


Запись обработки данных и вывода
     Когда процесс записывает один или несколько байтов в файл терминального устройства, они обрабатываются в соответствии с полем c_oflag (см. Раздел «Режимы вывода»). Реализация может обеспечить механизм буферизации; как таковой, когда вызов write () завершается, все записанные байты были запланированы для передачи на устройство, но передача не обязательно была завершена.

Специальные символы
     Некоторые символы имеют специальные функции на входе или выходе или и то, и другое. Эти функции суммируются следующим образом:

     INTR Специальный символ на входе и распознается, если включен флаг ISIG (см. Раздел «Локальные режимы»). Генерирует сигнал SIGINT, который отправляется всем процессам в группе процессов переднего плана, для которых терминал является управляющим терминалом. Если ISIG установлен, символ INTR отбрасывается при обработке.

     QUIT Специальный символ на входе и распознается, если флаг ISIG включен. Генерирует сигнал SIGQUIT, который отправляется всем процессам в группе процессов переднего плана, для которых терминал является управляющим терминалом. Если ISIG установлен, символ QUIT отбрасывается при обработке.

     ERASE Специальный символ на входе и распознается, если установлен флаг ICANON. Стирает последний символ в текущей строке; см. Обработка ввода канонического режима. Он не стирается за начало строки, как ограниченный символом NL, EOF или EOL. Если ICANON установлен, символ ERASE отбрасывается при обработке.

     KILL Специальный символ на входе и распознается, если установлен флаг ICANON. Удаляет всю строку, как указано символом NL, EOF или EOL. Если ICANON установлен, символ KILL отбрасывается при обработке.

     EOF Специальный символ на входе и распознается, если установлен флаг ICANON. При получении все байты, ожидающие чтения, немедленно передаются процессу, не дожидаясь новой строки, и EOF отбрасывается. Таким образом, если нет байтов ожидания (то есть, EOF произошел в начале строки), байтовый счетчик нуля возвращается из read (), представляющего индикацию конца файла. Если ICANON установлен, символ EOF отбрасывается при обработке. NL Специальный символ на входе и распознается, если установлен флаг ICANON. Это разделитель строк `\ n '.

     EOL Специальный символ на входе и распознается, если установлен флаг ICANON. Является дополнительным разделителем строк, например, NL.

     SUSP Если флаг ISIG включен, получение символа SUSP приводит к отправке сигнала SIGTSTP ко всем процессам в группе процессов переднего плана, для которых терминал является управляющим терминалом, а символ SUSP отбрасывается при обработке.

     STOP Специальный символ как на входе, так и на выходе и распознается, если установлен флаг IXON (управление выходом) или IXOFF (управление вводом). Может использоваться для временного приостановки вывода. Это полезно с быстрыми терминалами, чтобы предотвратить исчезновение вывода до его считывания. Если установлен IXON, символ STOP отбрасывается при обработке.

     START Специальный символ как на входе, так и на выходе и распознается, если установлен флаг IXON (выходное управление) или IXOFF (управление вводом). Может использоваться для возобновления вывода, который был приостановлен символом STOP. Если установлен IXON, символ START отбрасывается при обработке. CR Специальный символ на входе и распознается, если установлен флаг ICANON; это `\ r ', как обозначено в стандарте C {2}. Когда ICANON и ICRNL установлены, а IGNCR не установлен, этот символ преобразуется в NL и имеет тот же эффект, что и символ NL.


